from typing import List
import inflection
from tdw.dev.config import Config
from tdw.dev.code_gen.cs_xml.enum_type import EnumType
from tdw.dev.code_gen.cs_xml.struct import Struct
from tdw.dev.code_gen.cs_xml.klass import Klass
from tdw.dev.code_gen.cs_xml.util import INDENT_4, INDENT_8, INDENT_12, AUTOGENERATED

EXCLUDED_TYPES: List[str] = ["Config", "TrialManager"]
CONFIG = Config()


def enum_py(enum: EnumType) -> None:
    """
    Generate a Python Enum class and write the resulting text to disk.

    :param enum: The enum.
    """

    # Create the header.
    text = f"{AUTOGENERATED}\n\nfrom enum import Enum\n\n\nclass {enum.name}(Enum):\n{INDENT_4}" + '"""\n' + INDENT_4 + enum.description + f'\n{INDENT_4}"""\n\n'
    # Add members.
    for i, member in enumerate(enum.members):
        text += f"{INDENT_4}{member.name} = {i}  # {member.description}\n"
    # Write to disk.
    write_py(text=text, name=enum.name, import_path=enum.import_path)


def struct_py(struct: Struct) -> None:
    """
    Generate a Python class from a struct or class and write the resulting text to disk.

    :param struct: The struct or class.
    """

    if struct.name in EXCLUDED_TYPES:
        return
    py = f"{AUTOGENERATED}\n\n"
    imports = struct.get_imports()
    if len(imports) > 0:
        py += "\n".join(list(sorted(set(imports)))) + "\n\n\n"
    # Header.
    class_header = f"class {struct.name.split('<')[0].strip()}"
    if isinstance(struct, Klass):
        parents = list()
        if struct.parent is not None:
            parents.append(struct.parent.split('<')[0].strip())
        if struct.abstract:
            parents.append("ABC")
        if len(parents) > 0:
            class_header += "(" + ", ".join(parents) + ")"
    py += f"{class_header}:\n{INDENT_4}" + '"""\n' + INDENT_4 + struct.description.split('doc_gen_tags')[0].strip() + f"\n{INDENT_4}" + '"""\n\n'
    py += f"{INDENT_4}def __init__("
    # Constructor fields.
    constructor_parameters: List[str] = list()
    field_declarations: List[str] = list()
    param_docstrings: List[str] = list()
    super_fields: List[str] = list()
    constructor_fields = struct.fields[:]
    constructor_fields.extend(struct.inherited_fields[:])
    constructor_fields = [f for f in constructor_fields if f.py_field_type != "TrialStatus"]
    for field in constructor_fields:
        constructor_parameter = f"{field.name}: {field.py_field_type}"
        param_docstring = f"{INDENT_8}:param {field.name}: {field.description}"
        if field.py_default_value is None:
            constructor_parameters.insert(0, constructor_parameter)
            param_docstrings.insert(0, param_docstring)
        else:
            if field.is_collection or field.is_mutable_type:
                constructor_parameters.append(f"{constructor_parameter} = None")
            else:
                constructor_parameters.append(f"{constructor_parameter} = {field.py_default_value}")
            param_docstrings.append(param_docstring)
    # Instantiate with inherited fields.
    for field in struct.inherited_fields:
        if field.py_field_type == "TrialStatus":
            continue
        super_fields.append(f"{field.name}={field.name}")
    for field in struct.fields:
        if field.constant or field.static:
            continue
        # This field needs to have a None default value and it needs to get set within the constructor.
        if (field.is_collection or field.is_mutable_type) and field.py_default_value is not None:
            field_declaration = (f"{INDENT_8}if {field.name} is None:\n{INDENT_12}" +
                                 '""":field\n' + INDENT_12 + field.description + "\n" + INDENT_12 + '"""\n' +
                                 f"{INDENT_12}self.{field.name}: {field.py_field_type} = { field.py_default_value}\n{INDENT_8}else:\n{INDENT_12}self.{field.name} = {field.name}")
        else:
            if field.py_field_type == "TrialStatus":
                field_value = "TrialStatus.initializing"
            else:
                field_value = field.name
            # This is the field declaration if the type is not a collection.
            field_declaration = INDENT_8 + '""":field\n' + INDENT_8 + field.description + "\n" + INDENT_8 + '"""\n' + INDENT_8 + f"self.{field.name}: {field.py_field_type} = {field_value}"
        field_declarations.append(field_declaration)
    constructor_parameters.insert(0, "self")
    # Add the constructor parameters.
    py += ", ".join(constructor_parameters) + f"):\n{INDENT_8}" + '"""\n'
    # No arguments.
    if len(constructor_parameters) == 1:
        py += f'{INDENT_8}(no arguments)\n{INDENT_8}"""\n\n{INDENT_8}'
        if struct.parent is None:
            py += 'pass'
        else:
            py += 'super().__init__()'
    else:
        # Add the docstrings.
        py += "\n".join(param_docstrings) + f"\n{INDENT_8}" + '"""\n\n'
        # Add super.
        if struct.parent is not None:
            py += INDENT_8 + "super().__init__(" + ", ".join(super_fields) + ")\n"
        # Add the fields.
        py += "\n".join(field_declarations)
    py += "\n"
    # Write to disk.
    write_py(py, struct.name, struct.import_path)


def write_py(text: str, name: str, import_path: str) -> None:
    """
    Write a Python script to disk.

    :param text: The text of the script.
    :param name: The name of the class.
    :param import_path: The import path of the class.
    """

    directory = CONFIG.tdw_path.joinpath("Python").resolve()
    for folder in import_path.split("."):
        directory = directory.joinpath(folder)
    if not directory.exists():
        directory.mkdir(parents=True)
    directory.joinpath(inflection.underscore(name) + ".py").write_text(text, encoding="utf-8")
